[ERROR] 2020-07-13 09:28:56,421 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:96)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 09:29:09,003 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 09:29:19,835 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 09:29:20,092 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:96)
错误原因：readerIndex(0) + length(1024) exceeds writerIndex(104): PooledUnsafeDirectByteBuf(ridx: 0, widx: 104, cap: 1024)
[INFO ] 2020-07-13 09:33:24,546 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 09:33:40,399 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 09:33:40,487 method:com.laz.filesync.server.handler.FileServerHandler.exceptionCaught(FileServerHandler.java:46)
错误原因：readerIndex(0) + length(1024) exceeds writerIndex(104): PooledUnsafeDirectByteBuf(ridx: 0, widx: 104, cap: 1024)
[INFO ] 2020-07-13 09:37:13,877 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 09:37:16,758 method:com.laz.filesync.client.handler.MsgClientHandler.exceptionCaught(MsgClientHandler.java:172)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 09:37:29,402 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 10:53:31,692 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 10:53:41,384 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 10:54:00,278 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 10:54:09,761 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 10:55:37,519 method:com.laz.filesync.server.handler.FileServerHandler.exceptionCaught(FileServerHandler.java:34)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 10:55:42,204 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 10:56:02,086 method:com.laz.filesync.server.handler.FileServerHandler.exceptionCaught(FileServerHandler.java:34)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 10:56:06,352 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 10:56:16,448 method:com.laz.filesync.client.handler.MsgClientHandler.exceptionCaught(MsgClientHandler.java:172)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 10:56:34,032 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 10:56:48,396 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 10:57:28,570 method:com.laz.filesync.client.handler.MsgClientHandler.exceptionCaught(MsgClientHandler.java:172)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 10:57:45,304 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 10:57:57,173 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 10:58:38,479 method:com.laz.filesync.client.handler.MsgClientHandler.exceptionCaught(MsgClientHandler.java:172)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 10:59:46,440 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 10:59:55,758 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 11:00:40,937 method:com.laz.filesync.client.handler.MsgClientHandler.exceptionCaught(MsgClientHandler.java:172)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 11:01:22,088 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 11:01:50,173 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[INFO ] 2020-07-13 11:02:02,836 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:100)
收到服务端的文件检验和集信息1
[INFO ] 2020-07-13 11:02:03,309 method:com.laz.filesync.client.handler.MsgClientHandler.generateDiffFile(MsgClientHandler.java:133)
滚动计算： spend time :439ms
[INFO ] 2020-07-13 11:02:03,355 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:107)
生成同步差异文件到缓存目录C:\Users\lz578\AppData\Local\Temp\diff-2020-7-13-11-2-2
[ERROR] 2020-07-13 11:02:24,406 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:97)
错误原因：Adjusted frame length exceeds 1048576: 1347093256 - discarded
[INFO ] 2020-07-13 11:11:57,162 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 11:12:07,534 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[INFO ] 2020-07-13 11:12:07,691 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:100)
收到服务端的文件检验和集信息1
[INFO ] 2020-07-13 11:12:07,702 method:com.laz.filesync.client.handler.MsgClientHandler.generateDiffFile(MsgClientHandler.java:133)
滚动计算： spend time :10ms
[INFO ] 2020-07-13 11:12:07,704 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:107)
生成同步差异文件到缓存目录C:\Users\lz578\AppData\Local\Temp\diff-2020-7-13-11-12-7
[ERROR] 2020-07-13 11:12:07,716 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:97)
错误原因：Adjusted frame length exceeds 1048576: 1347093256 - discarded
[INFO ] 2020-07-13 11:13:41,859 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:71)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 11:13:53,821 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[INFO ] 2020-07-13 11:13:54,004 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:100)
收到服务端的文件检验和集信息1
[INFO ] 2020-07-13 11:13:54,015 method:com.laz.filesync.client.handler.MsgClientHandler.generateDiffFile(MsgClientHandler.java:133)
滚动计算： spend time :10ms
[INFO ] 2020-07-13 11:13:54,062 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:107)
生成同步差异文件到缓存目录C:\Users\lz578\AppData\Local\Temp\diff-2020-7-13-11-13-54
[ERROR] 2020-07-13 11:13:54,083 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:97)
错误原因：Adjusted frame length exceeds 1048576: 1347093256 - discarded
[INFO ] 2020-07-13 11:14:12,677 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[INFO ] 2020-07-13 11:14:18,975 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:100)
收到服务端的文件检验和集信息1
[INFO ] 2020-07-13 11:14:18,985 method:com.laz.filesync.client.handler.MsgClientHandler.generateDiffFile(MsgClientHandler.java:133)
滚动计算： spend time :9ms
[INFO ] 2020-07-13 11:14:18,988 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:107)
生成同步差异文件到缓存目录C:\Users\lz578\AppData\Local\Temp\diff-2020-7-13-11-14-18
[ERROR] 2020-07-13 11:15:06,466 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:97)
错误原因：Adjusted frame length exceeds 1048576: 1347093256 - discarded
[INFO ] 2020-07-13 11:15:20,036 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[INFO ] 2020-07-13 11:15:25,667 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:100)
收到服务端的文件检验和集信息1
[INFO ] 2020-07-13 11:15:25,678 method:com.laz.filesync.client.handler.MsgClientHandler.generateDiffFile(MsgClientHandler.java:133)
滚动计算： spend time :10ms
[INFO ] 2020-07-13 11:15:25,682 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:107)
生成同步差异文件到缓存目录C:\Users\lz578\AppData\Local\Temp\diff-2020-7-13-11-15-25
[ERROR] 2020-07-13 11:15:36,683 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:97)
错误原因：Adjusted frame length exceeds 1048576: 1347093256 - discarded
[INFO ] 2020-07-13 11:15:47,814 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[INFO ] 2020-07-13 11:16:08,592 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:100)
收到服务端的文件检验和集信息1
[INFO ] 2020-07-13 11:16:08,604 method:com.laz.filesync.client.handler.MsgClientHandler.generateDiffFile(MsgClientHandler.java:133)
滚动计算： spend time :11ms
[INFO ] 2020-07-13 11:16:08,607 method:com.laz.filesync.client.handler.MsgClientHandler.dealChecksumsMsg(MsgClientHandler.java:107)
生成同步差异文件到缓存目录C:\Users\lz578\AppData\Local\Temp\diff-2020-7-13-11-16-8
[ERROR] 2020-07-13 11:17:46,138 method:com.laz.filesync.server.handler.MsgServerHandler.exceptionCaught(MsgServerHandler.java:97)
错误原因：Adjusted frame length exceeds 1048576: 1347093256 - discarded
[INFO ] 2020-07-13 11:18:48,851 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 11:19:46,171 method:com.laz.filesync.client.handler.MsgClientHandler.exceptionCaught(MsgClientHandler.java:172)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 11:26:54,239 method:com.laz.filesync.server.FileSyncServer.start(FileSyncServer.java:72)
---------------------服务端启动--------------------
[INFO ] 2020-07-13 11:27:08,909 method:com.laz.filesync.client.FileSyncClient.start(FileSyncClient.java:73)
------------客服端启动----------------
[ERROR] 2020-07-13 11:57:35,012 method:com.laz.filesync.server.handler.FileServerHandler.exceptionCaught(FileServerHandler.java:34)
错误原因：远程主机强迫关闭了一个现有的连接。
[INFO ] 2020-07-13 14:59:36,644 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 14:59:52,406 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:04:13,059 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:04:44,437 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:04:51,638 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:06:42,598 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:06:47,804 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:06:50,689 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:06:57,622 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:10:20,552 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:10:22,025 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:10:27,530 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:10:43,339 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:11:29,917 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:11:31,785 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:11:36,512 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[INFO ] 2020-07-13 15:11:51,892 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:11:55,578 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:12:55,334 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:13:00,737 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:13:03,572 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:13:38,431 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:13:45,188 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:13:47,835 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:13:54,702 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:14:37,571 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:14:40,651 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:15:13,054 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:15:19,119 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:15:35,181 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:41:28,745 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:41:31,885 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:42:55,600 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:43:02,624 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:43:05,427 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:44:19,673 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
[INFO ] 2020-07-13 15:44:54,882 method:com.laz.filesync.server.FileReceiveServer.start(FileReceiveServer.java:38)
---------------------文件传输端口启动--------------------
[INFO ] 2020-07-13 15:44:58,471 method:com.laz.filesync.client.FileSendClient.start(FileSendClient.java:42)
文件服务器连接成功
[WARN ] 2020-07-13 15:50:56,263 method:io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
